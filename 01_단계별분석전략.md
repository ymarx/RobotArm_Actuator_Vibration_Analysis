# 01_단계별분석전략

Created: 2025년 11월 17일 오전 11:17

## 0. 전체 목표 다시 정리

- **입력 데이터**
    - CSV: `acc-X/Y/Z`, `Gyro-X/Y/Z`, `acc-Sum`, 메타데이터 (MeasFreq, Low/HighFreq, RMS/Peak 등)
    - 엑셀: 시료 단위 라벨 (`정상 / 소음 / 진동 / 표기없음`), 제품(100W/200W), 방향(CW/CCW) 등
- **최종 목표**
    1. **정상 vs 비정상(소음·진동)** 분류 (실무에 바로 쓰기 좋은 판단기)
    2. 장기적으로 **새로운 이상 패턴도 잡아낼 수 있는 이상탐지 기반** (오토인코더 등)
- **모델 전략**
    - 메인: **XGBoost(또는 비슷한 트리 기반)** 지도 분류기
    - 보조: **오토인코더 기반 anomaly score** (특히 정상-only 학습)

---

## 1. 1차 단계: 베이스라인 구축 (시간영역 + XGBoost 중심)

### 1-1. 데이터 인벤토리 및 연결

**목표:** “어떤 파일이 있고, 라벨이 어떻게 붙는지, 구조를 명확히 정리”

1. **파일 목록/메타 테이블 만들기**
    - 열:
        - `file_id` (고유 이름)
        - `product_power` (100W / 200W)
        - `direction` (CW / CCW)
        - `label_file` (정상 / 소음 / 진동 / 표기없음)
        - CSV 메타: `MeasFreq`, `Resampling`, `LowFreq`, `HighFreq`, 측정 시간 길이
2. **엑셀 ↔ CSV 매핑**
    - 엑셀의 시료 ID, 파일명, 제품, 방향, 라벨을 **정확히 매칭**해 하나의 “마스터 테이블”로 만듦.
3. **밴드패스 상태 정리**
    - 메타 `LowFreq=1`, `HighFreq=150` + 스펙트럼 확인 결과
        
        → **현재 CSV는 이미 1–150 Hz 밴드 제한된 상태**라고 명시
        
    - 계획서에 “추가 밴드패스는 ‘부분 대역 feature 추출용’으로만 사용”이라고 적어둠.

> 이 부분은 나중에 모든 코드/분석이 공유하는 “전역 진실”이라,
> 
> 
> 1차 단계에서 확실히 정리해두는 게 중요합니다.
> 

---

### 1-2. 전처리 & 세그먼트(윈도우) 설계

**목표:** “파일 → 윈도우(샘플) → feature 계산” 의 기본 단위를 정의

1. **시계열 전처리**
    - TimeStamp를 상대 시간(초)로 변환
    - 결측/NaN, 비정상 값(센서 클리핑 등) 체크 및 처리 전략 정리
    - 필요시 **offset 제거(평균 제거)** 정도만 수행
        
        (이미 밴드패스가 되어 있으므로 과도한 필터링은 하지 않음)
        
2. **윈도우 길이 & hop 결정 (1차 가이드)**
    - 예시:
        - 윈도우 길이: 0.5초 또는 1초 (샘플링 512 Hz → 256 or 512 샘플)
        - hop: 50% overlap (0.25초 or 0.5초 간격)
    - 이유:
        - 충분한 진동 패턴을 포함하면서
            
            데이터 수를 늘릴 수 있는 타협점
            
3. **시동·정지 구간 처리**
    - 각 파일에서 **안정 구간**(중간)만 윈도우로 쓰도록 규칙 정의
        - 예: 전체 길이의 앞/뒤 10~20%는 버리고 가운데만 사용
    - 정확한 비율은 EDA에서 한 번 확인 후 결정.
4. **라벨링 단위**
    - 파일 라벨을 윈도우에 그대로 상속:
        - 파일 라벨이 `정상`이면 → 그 파일에서 추출한 윈도우는 모두 `정상`
        - `소음, 진동` 등도 마찬가지
    - 다만, 추후에 파일 내부에서도 이상 구간이 있는지 AE로 보는 구조는 2차에서.

---

### 1-3. 1차 feature 세트 (시간영역 중심)

**목표:** “계산 간단하고 직관적인 feature로 베이스라인 성능 확보”

각 **윈도우 × 채널**에 대해 계산:

1. **기본 통계/진폭 feature**
    - `RMS` (root mean square)
    - `Peak` (최대 절대값)
    - `mean`, `std`
    - `crest_factor = Peak / RMS`
    - `kurtosis`, `skewness` (비정상 분포 탐지에 좋음)
2. **채널 구성**
    - 가속도: `acc-X/Y/Z`, `acc-Sum`
    - 자이로: `Gyro-X/Y/Z`
    - ⇒ 7개 채널 × 위 통계들 = 꽤 많은 feature,
        
        하지만 XGBoost는 이런 탭글에 잘 맞음.
        
3. **메타 feature**
    - `product_power` (100 / 200)
    - `direction` (0=CW, 1=CCW)
    - 필요시 `MeasFreq`도 추가 (지금은 거의 고정값이라 영향 적을 수 있음)
4. **파일 수준 feature (선택)**
    - 한 파일 전체의 평균 RMS, 최대 RMS 등을 별도 테이블로 만들어
        
        나중에 “파일 단위 분류”에도 활용할 수 있게 준비
        
        (1차에서는 윈도우 단위에 집중)
        

---

### 1-4. 데이터 분할 & 샘플링 전략 (1차 버전)

**핵심 원칙: “데이터 누수(같은 파일이 train/val 양쪽에 들어가는 것)를 최대한 피한다”**

1. **파일 단위 분할 우선**
    - 이상적으로는:
        - 각 제품(100W, 200W)별로
            - 정상 파일들 중 일부: train
            - 나머지 정상 파일: val/test
            - 불량 파일들도 마찬가지로 분할
    - 현실: 정상 파일이 아주 적다면
        - 하나의 정상 파일을 시간 구간으로 나눠
            - 앞: train, 중간: val, 뒤: test
                
                정도로라도 분리.
                
2. **그 후 윈도우 분할**
    - train에 속한 파일들에서만 윈도우 생성 → train 샘플
    - val/test 파일에서 윈도우 생성 → val/test 샘플
    - **파일을 섞어서 윈도우를 만들고 나누는 방식은 피함.**
3. **클래스 불균형 처리**
    - 정상과 불량(소음+진동)을 하나로 묶어 *이진 분류*부터 시작:
        - target: `normal` vs `abnormal`
    - 윈도우 수가 너무 한쪽으로 치우치면
        - 정상 : 비정상 ≈ 1:1 ~ 1:3 정도로
        - oversampling / undersampling 적용
4. **제품별 모델 분리 (1차 기준)**
    - 처음에는
        - 100W 전용 모델
        - 200W 전용 모델
    - 이유:
        - 제품마다 구조/특성이 다를 수 있고,
        - 데이터가 많지 않을 때는 분리해서 보는 편이 해석이 쉽기 때문.

---

### 1-5. 1차 모델링: XGBoost 베이스라인

**목표:** “시간영역 feature만으로 정상 vs 비정상 분리가 어느 정도 되는지 확인”

1. **문제 정의**
    - 1단계: 이진 분류 (`normal` vs `abnormal`)
        - `abnormal = 소음 + 진동 (필요시 표기없음 제외)`
    - 2단계(추후): 3클래스 (`정상 / 소음 / 진동`)
2. **모델**
    - XGBoost(or LightGBM) 분류기
    - 입력: 윈도우별 feature 벡터
    - 출력: class 확률
3. **평가 지표**
    - Accuracy
    - Precision / Recall / F1 (특히 `abnormal` 클래스 기준)
    - Confusion matrix
    - ROC-AUC / PR-AUC (이상 탐지 성능 느낌 보기)
4. **해석**
    - feature importance (gain, split count)
    - SHAP 등으로
        - 어떤 feature들이 `abnormal` 판정에 기여하는지 확인
    - 이를 바탕으로
        - “어떤 축/대역이 중요한지”에 대한 직관 형성
            
            → 2차 단계 feature 설계에 반영
            
5. **1차 결과의 역할**
    - “시간영역 + 기본 통계만으로 어느 정도까지 구분이 되는지” 확인
    - **EDA + 베이스라인** 용도로,
        - 모델 성능이 꽤 좋다면:
            
            → 나중에 주파수 feature는 “성능 개선 + 해석 강화” 용도
            
        - 성능이 애매하다면:
            
            → 2차에서 주파수/오더/AE가 필수라고 판단
            

---

### 1-6. 1차에서 오토인코더는 어디까지 할까?

1차 단계에서 오토인코더는 **“구조 설계 + 최소 구현” 수준**만 해두고,

본격적인 튜닝과 활용은 2차로 미루는 쪽을 추천합니다.

1. **feature 기반 간단 AE 스켈레톤**
    - 입력: 윈도우별 feature (RMS, Peak, kurtosis 등)
    - 인코더: Dense → latent 8~16 dim
    - 디코더: 다시 Dense → 원래 feature 차원
    - 손실: MSE
2. **학습 데이터**
    - 정상 윈도우만 사용 (파일 분할 규칙 준수)
3. **출력**
    - reconstruction error를 “anomaly score 후보”로 저장만 해둠
    - 1차 단계에서는 성능 튜닝까지 집착하지 않음
        
        → 2차에서 XGBoost 결과와 함께 본격 해석/활용
        

**이렇게 해두면:**

- 2차 단계에서 “AE 완전 처음부터 설계”가 아니라
    
    “이미 구조가 있고, score도 한 번 계산해둔 상태에서 고도화”만 하면 됩니다.
    

---

## 2. 2차 단계: 고도화 (주파수/오더 feature + 오토인코더 + 운영 설계)

1차에서 얻은 결과를 바탕으로, **필요한 만큼** 2차를 확장하는 구조로 설계합니다.

### 2-1. 고급 feature 설계

1. **주파수/대역별 feature**
    - 각 윈도우에 대해 FFT(or Welch PSD) 계산 (1–150 Hz)
    - 의미 있는 밴드 나누기 예:
        - 1–30 Hz (저주파: 구조적인 흔들림, 저속 모드)
        - 30–80 Hz (중간 주파수)
        - 80–150 Hz (상대적으로 고주파)
    - 각 밴드별
        - band-RMS (에너지)
        - band power 비율 (각 밴드/전체)
2. **오더(회전수 정수배) feature**
    - 메타 `MeasFreq` 기반으로
        - 1×, 2×, 3× 근처의 dB or RMS
    - XGBoost에 넣어:
        - 회전불균형/정렬불량 등의 징후를 포착할 수 있는지 확인
3. **베어링 특화 feature (필요시)**
    - envelope 분석 or 고주파 band(현재는 150 Hz까지만이지만,
        
        향후 데이터에 따라 확장 가능)
        
    - 특정 결함 주파수대(BPFO, BPFI 등)를 안다면,
        
        그 대역 에너지 계산
        

### 2-2. 2차 모델링: XGBoost 고도화 + AE 본격 사용

1. **XGBoost 고도화**
    - 1차 시간영역 feature + 2차 주파수/오더 feature 결합
    - 하이퍼파라미터 튜닝 (learning rate, depth, tree 수, subsampling 등)
    - K-fold cross-validation (파일 단위)
    - 제품별 모델 vs 통합 모델 비교
2. **오토인코더 고도화**
    - feature 기반 AE 성능 점검:
        - 정상·비정상의 reconstruction error 분포 비교
        - 임계값 설정 전략(예: 정상 상위 99%, mean+3σ 등)
    - 필요시 **1D-CNN/LSTM AE (원신호 기반)** 도입:
        - 입력: 윈도우의 시계열 (T×채널)
        - 장점: 파형 모양까지 반영
        - 단점: 구현/튜닝 복잡 → 2차 후반부 과제로 배치
3. **XGBoost + AE 결합 로직 설계**
    - 예시:
        - XGBoost = 정상 & AE score < T → 정상
        - XGBoost = 정상 & AE score ≥ T → “의심 정상” (주의)
        - XGBoost = 비정상 → 비정상
    - 이 로직은 나중에 “운영·프로덕션 설계 챕터”와 연결

### 2-3. 운영·확장 관점 설계

2차 단계에서는 분석 성능뿐 아니라, “나중에 실제로 쓸 때 어떤 구조로 돌아갈지”도 함께 설계합니다.

- 데이터가 늘어났을 때
    - 새로운 파일을 자동으로 세그먼트/feature화
    - 기존 모델에 넣어 score 산출
- 분기 관리
    - 100W/200W, CW/CCW별로 어떤 모델/threshold를 쓸지 config화
- 드리프트 모니터링
    - 정상 파일들의 RMS/feature 분포가 시간이 지나며 변하는지
    - AE score가 전체적으로 올라가는지 등

---

## 3. 요약: 1차 vs 2차 단계 역할 구분

### 1차 단계 (지금 설계하는 핵심)

- **목표**
    - 데이터 구조/전처리/세그먼트 방식 확정
    - 시간영역 feature + XGBoost로 베이스라인 성능 확인
    - 간단 AE 구조까지 만들어 “미래 사용” 준비
- **결과물**
    - 안정적인 “세그먼트 → feature 테이블 생성” 코드
    - 이진 분류 기준에서의 성능 수치와 해석 (어느 feature가 중요한지)
    - AE reconstruction error의 초벌 분포

### 2차 단계

- **목표**
    - 주파수/오더/베어링 특화 feature 추가
    - XGBoost 및 AE 고도화
    - XGBoost + AE 결합 로직, 운영 구조 설계
- **결과물**
    - 고성능/해석 가능한 모델
    - 실제 서비스 관점에서의 판단 로직, threshold, 모니터링 전략